

# vue基础

# vue重点

1:语法都是写在html标签上面

2:在html标签上	语法=	加上""是字符串	不加""	是data数据或者方法





## vue的几种安装

1：下载.js文件	直接src引入

2：cdn 引入

3：npm安装

现在刚开始学先用第一种简单的





## 创建一个vue

```js
    const app = new Vue({
      el:"#box",  //vue用来管理的dom元素	使用id选择器
      data:{      //数据
        name:"zs",
      },
      methods: {  //用来定义方法的
        get:function(){
          console.log("1");
        }
      },
    })
```





## 插值操作

### Mustach语法插值

Mustach语法就是{{}}	里面写data对象里 的k，vue就会自动解析数据并渲染到dom上	相当于innetText

```html
  <div id="box">
     <!-- {{}}	里面写data对象里的k -->
    <h2>{{name}}</h2>
      
    <!--也可以进行拼接	-->
    <h2>{{name + age}}</h2>
      
  	<!--数字类型可以加减乘除运算	-->
    <h2>{{age * 2}}</h2>

</div>
  
  <script>
    const app = new Vue({
      el:"#box",
      data:{
        name:"zs",
        age:15
      }
    });
  </script>

```





### v-once指令的使用

指令是写在 html标签上的	vue会帮我们解析

v-once	只渲染一次数据，改变数据不会再次渲染

```html
    <h2 v-once>{{name}}</h2>
```





### v-html指令的使用

语法 v-html="data"

v-html：把data数据当作html解析并渲染，相当于innetHtml

```html
  <div id="box">
    <h2 v-html="message"></h2>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        message: "<a href='http://wwww.baidu.com'>baidu</a>",
      }
    });
```





### v-pre指令的使用

v-pre：不解析mustach 语法





## v-bind动态绑定属性

### v-bind的基本使用

v-bind：在dom属性前面添加，那么属性的值就可以是data数据

简写	:

```html
  <div id="box">
      <!-- v-bind添加到属性前面，那么属性的值就可以是data数据 -->
      <img v-bind:src="imgurl" alt="">
      
      <!--	简写 在属性前面写上 : -->
      <img :src="imgurl" alt="">
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        imgurl:"https://www.runoob.com/wp-content/uploads/2017/01/vue.png",
      }
    });
  </script>
```



 

后面可以加boolean来决定是否添加该属性

```html
<button :disabled="true" @click="decrement">111</button>
```





### v-bind在class类的使用

<div v-bind:class="{类名:boolean}"></div> 

```html
  <div id="box">
    <!-- 在class进行动态绑定时候,我们可以传一个对象   如果boolean为true，那么类名添加，如果false，类名删除
          在开发中，专门在data里面声明一个boolean变量，进行控制
    -->
      
    <!-- <div v-bind:class="{类名:boolean}">{{name}}</div> -->
    <div v-bind:class="{active: isActive}">{{name}}</div>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        name:"zsf",
        //用来控制类名的变量
        isActive:true
      }
    });
  </script>
```



### v-bind在style中的使用

### <div v-bind:style="{css属性名:css属性值}"></div> 

```html
  <div id="box">
    <!-- 在style进行动态绑定时候,我们可以传一个对象   
          在开发中，我们一般自定义一个属性值
    -->
    <!-- <div v-bind:style="{css属性名:css属性值}">{{name}}</div> -->
    <div :style="{color: final}">{{name}}</div>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        name: "zsf",
         //自定义一个属性值
        final:"pink",
      }
    });
  </script>
```





## 计算属性

### 使用

计算属性是写在vue{}	里面的	用来处理数据

```js
    const app = new Vue({
      el: "#box",
      data: {
        name: "zsf",
        firstName:"sss",
        lastName:"zzz",
      },
      computed:{
        fullname:function(){
          return this.firstName + this.lastName;
        }
      },
    });
```



### 计算属性和方法的对比

我们发现计算属性和方法很相似

计算属性是有缓存的，如果计算属性里面的值不变，多次调用计算属性，它只会执行一次

方法调用一次，就会执行一次，效率没有计算属性好



## es6的补充

### let和const关键字

let就是var的升级，let声明的变量有作用域，不会出现变量共享问题.

const就是用来定义常量的。

es5没有作用域



### es6对象字面量增强写法

属性

```js
var name = "zs"
var age = 15;

//es5写法，把上面的值，赋值给下面的属性，
var o = {
    name:name;
    age:age
}

//es6写法，结果是相同的
var o = {
    name,
    age,
}
```



方法

```js
//es5写法
var o = {
    run:function(){
        
    }
}

//es6写法	省略了function，结果是一样的
var o = {
    run(){
        
    }
}
```





## v-on事件监听

### 基本使用

语法 v-on:事件=

在vue中，想绑定事件，直接在标签上写v-on



v-on简写(语法糖)

@事件=



```html
  <div id="app">
    <button v-on:click=getName>点击</button>
    <!-- v-on简写1 -->
    <button @click=getName>点击</button>
  </div>
```



@事件=	写方法，直接写

写表达式要带""



### 参数传递event对象

如果想传递event事件对象，那么在实参写上$event

```html
  <div id="app">
      <!--	传递event事件对象	-->
    <button v-on:click=getAge(18,$event)>点击</button>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
      },
      methods: {
        getAge(age,event){
          console.log(age);
          console.log(event);
        }
      },
    });
  </script>
```



### v-on修饰符

修饰符就是在后面加上.

.stop	阻止事件冒泡	

.prevent	阻止元素默认事件

.keyCode	当事件是对应的键盘码，执行事件

.once	执行一次事件

如何使用？在事件后面加上	.对应的修饰符	就行

比如	<button @click.stop=f1></button>



## 条件判断

vue中的条件判断是写在dom标签上的，用来判断是否渲染元素



### v-if和v-else if 和v-else

v-if="boolean"	如果为true就显示元素，false隐藏

```html
  <div id="app">
      <!--	用一个变量控制	-->
    <div v-if=isIf>123</div>
    <div v-else>456</div>
  </div>
```



### key的使用

在vue中，如果有两个相同的元素，vue创建第一个，然后第二个不会创建，会把第一个创建好的元素拿来用，改变属性,id，但是不会改变value属性。如果想渲染两个新的元素，那么在dom元素上加上 key，两个dom元素的key不一样，就会渲染两个

语法 key="值"	值随便填



### v-show

v-show和 v-if 一样，都是决定元素显示和隐藏的

语法 v-show:"boolean"	true显示，false隐藏

区别：

v-show 为false的时候，元素是display:none	隐藏的

v-if	为false，元素直接删除	





## v-for的使用

v-for是写在html标签上的，能遍历几次，就渲染几个元素

### 遍历数组

语法：v-for="item,index in 数组"

item是每次遍历的值，index是下标

```html
  <div id="app">
    <ul>
      <li v-for="item,index in names"> {{index}} {{item}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        names:["zs","ls","ww"],
      },
      methods: {

      },
    });
  </script>
```





### 遍历对象

语法：v-for="value,key,index in 对象"

```html
  <div id="app">
    <ul>
      <li v-for="value,key in stu"> {{value}} {{key}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        stu:{
          name:"zs",
          age:18,
          sex:"man"
        }
      },
      methods: {

      },
    });
  </script>
```





### vue中的点击谁给谁加style

设置一个crrent变量，给每个li添加事件，每次点击，crrent = index，crrent就相当于被点击的那个。然后current和index比较，为true就是点击到了。

```html
  <div id="app">
    <ul>
      <li v-for="item,index in stu" :class="{active:currentIndex === index}" @click="changeColor(index)">{{item}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el: "#app",
      data: {
        stu: ["zs", "ls", "ww", "xh"],
        currentIndex:0,
      },
      methods: {
        changeColor(index){
          this.currentIndex = index;
        }
      },
    });
  </script>
```









## v-model在表单的使用

### 基本使用

v-model是用来双向绑定的，表单的value变data的数据也变，data数据变，表单value变。

语法	v-model="data数据"

```html
  <div id="app">
    <input type="text" v-model="username">
    {{username}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        username:"",
      }
    });
  </script>
```





### v-model原理

就是给表单value动态绑定数据，然后绑定表单改变事件，发生改变把表单value在给data数据

event.target.value 能获取表单value

```html
  <div id="app">
    <input type="text" :value="username" @input="change">
    {{username}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        username:"123",
      },
      methods: {
        change(){
          this.username = event.target.value
        }
      },
    });
  </script>
```





### 在radio中使用

直接使用就行，没难点。

给radio加上v-model=""	只要是同一个data数据	radio就会互斥

name=""	在提交服务器值是key的存在

```html
  <div id="app">
    <input type="radio" value="男" v-model="sex">男
    <input type="radio" value="女" v-model="sex">女
    {{sex}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        sex:"",
      }
    });
  </script>
```



### 在checkbox中使用

1：单个checkbox，data数据是boolean类型，并且value不用加

2：多个checkbox，data数据是数组类型

```html
  <div id="app">
    <!-- 单个 checkbox 使用  -->
    <input type="checkbox" v-model="isAgree">我同意协议
    {{isAgree}}

    <p></p>
    
    <!-- 多个checkbox的使用 -->
    <input type="checkbox" value="抽烟" v-model="hobby">抽烟
    <input type="checkbox" value="喝酒" v-model="hobby">喝酒
    <input type="checkbox" value="烫头" v-model="hobby">烫头
    {{hobby}}

  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        isAgree:false,
        hobby:[],
      },
      methods: {
      },
    });
  </script>
```





### v-model修饰符

.lazy	用户在text文本框，敲回车或者光标离开text文本框，data数据才会更新。默认情况是实时更新data

.number	把用户在text文本框的内容变成number类型。默认是string类型

.trim	去掉用户在文本框输入的左右空格。









# 组件化开发

组件化开发就是把一个页面，用多个vue文件来写

## 基本使用

分三步

1：创建组件对象	2：注册组件	3：使用

```html
  <div id="app">
    <!-- 3：使用 -->
    <mycpn></mycpn>
  </div>

  <script>
    //1；创建组件对象
    const cpn = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    //2：注册组件
    // component("组件标签名",组件对象)
    Vue.component("mycpn", cpn);
      
   	  var app = new Vue({
      el: "#app",
    });
  </script>
```







### 局部组件

使用 Vue.component()	注册的组件都是全局组件，能在多个vue实例下使用。但是开发中只会创建一个vue实例，并且使用局部组件

局部组件在vue实例下注册就行了

```js
    //1；创建组件对象
    const cpn = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    var app = new Vue({
      el: "#app",
        //2：注册组件
        //在vue实例里注册组件,k就是标签名,value就是组件对象
      components:{
        mycpn:cpn,
      }
    });
```





### 父子组件

有两个组件cpn1 cpn2，在cpn2里面注册cp1组件，那么cpn2就是父组件，cpn1就是子组件

```js
  <script>
    const cpn1 = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    const cpn2 = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `,
        //在组件2里注册组件1
      components:{
        cpn1:cpn1
      }
    })
```





### 注册组件简写(语法糖)

直接在component(标签名,组件对象)	组建对象传一个对象:	{template:`` }	

```js
  <script>
    //全局组件 语法糖写法
    Vue.component("cpn1",{template:`<div>你好</div>`})


    var app = new Vue({
      el: "#app",
      //局部语法糖写法
      components:{
        cpn2:{template:`<div>哈哈哈哈</div>`}
      }
    });
  </script>
```





### 组件化模版抽离写法

就是把html	写在body里面，不在写到js里面

使用 <template id="cpn1"></template> 标签。然后加上id，{template:id名}	就可以了

```html
<template id="cpn1">
	<div>哈哈哈</div>
</template>

<template id="cpn2">
	<div>呵呵和</div>
</template>


<script>
	//模版抽离
    Vue.component("cpn1",{template:cpn1})


    var app = new Vue({
      el: "#app",
	//模版抽离
      components:{
        cpn2:{template:cpn2}
      }
    });
  </script>
```





### 模块的data

模块也有data，但是data必须是函数类型并且返回对象，这个对象里面就是data数据。这是因为多个模块调用函数，作用域不会共享，对象会共享。

```html
  <template id="cpn1">
    <div>
      {{name}}
    </div>
  </template>

  <script>
    Vue.component("cpn1", {
      template: "#cpn1",
        //data必须是函数类型并且返回对象，这个返回的对象里面就是data数据。
      data() {
        return {
          name: "zs"
        }
      }
    });

    var app = new Vue({
      el:"#app"
    });
  </script>
```







## 组件通信

组件通信就是组件之间的data数据如何进行发送接收



### 父传子类型限制

props:{

name:String,

age:Number,

}

```html
  <div id="app">
    <!--2：在父组件里传数据 -->
    <cpn1 :cname="name" :age="age"></cpn1>
  </div>

  <template id="cpn1">
    <div>
      {{cname}}
      {{age}}
    </div>
  </template>

  <script>
    var cpn1 = {
      template: "#cpn1",
      //1：使用props来接收数据，k就是要接收数据名字，value就是类型限制
      props: {
        cname: String,
        age: Number
      }
    }

    var app = new Vue({
      el: "#app",
      data: {
        name: "zzzzz",
        age: 18
      },
      components: {
        cpn1: cpn1
      }
    });
  </script>
```





### 父传子默认值

要接收的数据的名称是对象

props:{

​	name:{

​	type:String,

​	default:"aaaa"

​	}

}

```html
  <div id="app">
    <!--2：在父组件里传数据 -->
    <cpn1></cpn1>
  </div>

  <template id="cpn1">
    <div>
      {{cname}}
    </div>
  </template>

  <script>
    var cpn1 = {
      template: "#cpn1",
      //1：使用props来接收数据，要接收的数据可以有默认值
      props: {
        cname: {
          type: String, //限制要接收的值的类型
          default: "adssda",  //默认值
          required:true,  //在使用这个模块，必须传这个参数，不然报错
        }
      }
    }

    var app = new Vue({
      el: "#app",
      data: {
        name: "zzzzz",
        age: 18
      },
      components: {
        cpn1: cpn1
      }
    });
  </script>
```



































为什么要使用模块化？
如果不使用模块化，那么会有变量被修改，逻辑错误，不方便维护等问题
什么是模块化？
核心就是导入和导出，模块化也有多种规范：如CommonJS  ES6等

webpack是什么
webpack就是模块和打包,把开发时候写的模块化代码打包成大部分浏览器可以使用的

webpack运行需要(依赖)node,node环境运行需要各种依赖包，npm就是用来管理包的node packages manager


dist目录用来存放用来发布的代码,src存放源代码




---------------------------
一、webpack的基本配置
webpack.config.js文件
每个目录下应该有一个webpack.config.js的文件，这个文件用于配置webpack的
2:webpack自动化打包，在之前使用的打包是webpack ./(要打包的js入口文件)  ./(打包后的js文件)
如何在终端输入webpack 就让它自动打包？

使用如CommonJS命令在config文件里配置
这个path必须是绝对路径，如果直接写上绝对路径，可以是可以，但是项目一旦发生改变，我又要
重新写path==	如何解决？

modlue.exports = {
  entry:'./src/main.js',
  output:{
    path:,
    filename:'bundle.js'
  }
}

package.json文件
使用node命令,使用node命令之前要初始化
npm init


const path = require('path')

这时候可以使用node了，使用path.resolve(__dirname ,'dist')获取绝对路径，这时候就配置好了
module.exports = {
  entry:'./src/main.js',
  output:{
    path:path.resolve(__dirname ,'dist'),
    filename:'bundle.js'
  }
}


全局webpack和局部webpack
全局webpack是计算机上安装的,但是每个项目里面也可以有一个webpack

在项目中安装局部webpack
npm install webpack@3.6.0 save-dev
安装好后json文件多了个dependencies，这个是开发时依赖
save是运行时依赖

命令的简化
npm run .. 
后面的命令是json文件里的script的对象后面语法
写上	"build":"webpack"
npm run build 
自动打包

总结：
1:一个项目先创建webpack.config.js文件，在里面配置webpack打包语法
2:初始化node环境，因为上面的绝对路径有依赖node语法 npm init
3:安装局部webpack  npm install webpack@3.6.0 save-dev

以上三步是webpack的基本配置





----------------------------
二:webpack的css处理
在使用css中，我也希望是模块化，只引用一个
在上面一，基础上添加一个css文件，在main.js中依赖导入(依赖这个css文件)
得webpack在用这一个main.js文件，把css也给我打包了
require("./css/ordinary.css")

npm run build 
报错
You may need an appropriate loader to handle this file type.


所以需要一个loader,loader可以看作webpack的升级，webpack本身只能打包js，
但是我们也需要其他的，所以loader就出现了，不同的loader有不同的功能

我们去官网上找loader webpackjs.com

随后安装npm npm install --save-dev css-loader
--save 指的是运行和开发公用一个
--save-dev 只开发时候使用

在webpack.config.js配置

值得一提的是，webpack 的版本和loader 版本，要兼容，如果代码没错，那么请卸载
loader:npm uninstall 名称，在指定loader版本安装 npm install loader名称@3.6(版本号)


css-loader用来加载css的，不会把css加载到html，如果要加载在添加一个style-loader，具体看文档


总结：webpack只能打包js，如果想处理其他文件，请下载不同的loader
最后加载成功，webpack把css代码直接添加到dom中，而我index.html只是引用了一个main.js，就可以做到
全部导入，这一点很厉害..





----------------------------
三：loader处理图片
在css里添加图片，加载css时候会将图片当作模块进行加载

去官网上找处理图片loader
url-loader
npm install --save-dev url-loader@1.1.2

url-loader 
limit: 20000  这个属性，后面是20000kb，如果图片小于这个，
那么在浏览器以base64的形式显示

如果图片大于这个，那么将使用file-loder解析，把图片放到dist目录
filter的使用
如果图片大于limit，发现浏览器并不能解析图片，因为图片在dist目录
在webconfigjs中添加 publicPath:'dist/',   本项目url默认路径都已这个开始

filter-loader有一个属性name。这个属性可以设置在filter图片中的名字


--------------
四：babel-loader
这个loader用来打包模块,把代码全部转为es5





---------------
五：webpack里面使用vue
在webpack中vue也是一个模块
1:安装vue npm install vue --save
2:导入vue  import Vue from 'vue'
3:vue分runtime-only 和 runtime-compiler

runtime-only运行版本，不能有template vue也是一个template所以报错
runtime-compiler 开发版本
默认是 only版本

4:指定版本(官网上有)
module.exports = {
  // ...
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js' // 用 webpack 1 时需用 'vue/dist/vue.common.js'
    }
  }
}



----------------------------
六：vue在webpack中使用
一个组件同时出现template 和el  template的模版会代理el前端挂载的dom
这样前端就不用写代码了,就一个html页面。

npm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev
安装vue模块，这样可以在webpack使用vue



----------------
七：webpack使用插件
插件是webpack的扩充，而loader是类型转换器
具体在官方文档里看吧。。



----------------
八：webpack搭建本地服务器
我们没写一次代码想测试就'webpack'一次，有没有解决办法？
搭建本地服务器 	npm install --save-dev webpack-dev-server@2.9.3
dev-server是一个模块，它的作用是搭建一个本地服务器，我们的代码全在
内存里跑，并且是实时刷新的，我们代码并不会存在硬盘上，代码写好后,'webpack'一次
就存到硬盘了


---------------
九：把webpackconfigjs抽离
我们发现一个config文件里很多代码，我们给它分离出去，一个开发时候用，一个编译时候用



-------------------
十：使用vue cli 构建项目
之前配置太麻烦了，使用cli可以一键配置，cli也依赖node，下载是使用npm的
具体下载看官网




----------------
十一：runtime-compiler 和runtime-only
在构建项目时候可以选择使用这其中一个，这两个有什么区别？
compiler:在渲染dom元素时候，过程如下:
template -> ast -> render -> vdom - dom
compiler是先把template编译

only:在渲染dom元素的时候，过程如下
render -> vdom -> dom
直接省略了前两步

它们的区别在于main.js中。在noly中，我只需要提供一个render函数就可以渲染dom元素 

.vue文件中的template 直接会被vue-template-compiler 这个编译为runder函数，所以only是没有template的存在
	




-----------------------
十二：前端渲染和后端渲染
第一阶段：后端渲染:发送url，后端处理数据，后端使用jsp,php 把数据渲染到dom元素，
在发送给浏览器，浏览器显示

第二阶段:前后端分离：前端先请求静态资源，然后再以ajax的方式像api服务器发送请求，
后端接收数据并处理数据，后端json返回前端，前端接收，在渲染，每次请求都是一次渲染

第三阶段：
spa阶段，前端请求一资源，前端进行不是必须请求数据的操作，就可以从第一次请求的
资源中，进行分离，直接显示到浏览器

后端渲染就是url和后端的一个映射关系，发送哪个url，后端对应的渲染
前端渲染就是url和前端的一个映射关系，后端负责数据传输无须渲染，前端负责数据的展示

后二阶段都是前端渲染



-----------------------
十三：url的hash 和history
location.hash 给当前页面一个值

history.puchState() 给页面一个值，这个值以栈结构保存
history.replaceState() 替换当前页面，不进行保存
history.go(int) 返回或前进栈里面的网页
history.back() 前进一个网页 back()=go(1)


---------------------
十四：npm 使用router前端路由
前端路由就是url和页面的映射关系
cli构建项目时候选择router，在router目录下index.js 注册router插件，创建router对象，导出
rouoter对象，并在main.js中引入router对象



tag="button" 设置路由组件渲染的元素
replace 路由元素不会有历史记录，不进行pushState，
active-class=""	设置单个路由元素默认class值


------------------
十五：通过代码进行路由跳转
给dom绑定事件，组件里写对应的methods，调用this.$router.push('/about')，router
就相是index.js定义的router，vue会给每个模版一个 push=pushState一样

-----------------
十六：动态路由
在某些场面需要传递用户参数，比如 user/userid
这个id怎么从首页传过去？
1:单个传递
1、在router中配置path /user/:userid  :是特殊符号
2、在router-link 配置to v-bind:to="'/user/'+name"  

2:多个传递
1、:to="{path:'profile',query:{name:'zhangsan',age:12}直接在router-link上配置
2、给dom绑定事件，在方法里配还是$router这个方法，只不过是对象形式
this.$router.push({path:'/profile',query:{name:'zhangsan',age:'18'}})

-----------------
十七:嵌套路由
路由下面还有路由，在inex.js(router)配置children


--------------------
十八：路由懒加载
在index.js(router)文件中，配置模块和path对应关系
模块是需要一个个导入的 import ...
但是这样在打包dist文件时候，会全部为打包一个js文件，在后期这个文件会越来越大
用户请求这个文件也会很慢，体验不好

路由懒加载就是解决这的，路由懒加载可以把导入的模块，打包时候分为一个个的js
const profile = () => import('../components/Profile') 路由懒加载的写法



-------------------------
十九：router 和 route
router和route都可以在模块中通过this. 来获取到，因为vue配置的
router 是index.js中的那个router，用来控制页面跳转的，因为它的方法.
route 是 index.js中的route对象，是个数组[],route对象也是routes映射关系的活跃(被点击)对象


----------------
二十：全局守卫
用来监控页面的，有多个方法，如果网页发生对应的操作，将调用这个全局守卫函数


-----------------------
二十一：router-view 和keep-alive
每个模块都有自己的生命周期

//组件生命周期函数，当函数被创建，调用此函数
created(){},

//当函数被销毁，调用此函数，组件显示---路由跳转其他页面，就是一次创建销毁
destroyed(){},

//当组件是活跃状态，执行此函数，此函数对应的组件必须keep-alive里面，才会生效，才不会被销毁
activated() {},

//当组件是不活跃状态，执行此函数，此函数对应的组件必须keep-alive里面，才会生效，才不会被销毁
deactivated(){},

如果模块渲染在route-view中，那么每次点击，跳转其他路由，就是一次生命周期(创建---离开---销毁)

router-view可以在keep-alive中，如果这样，跳转其他路由，本模块被不销毁(创建--离开---依然存在)












------------------------------------------
vueX
一：什么是vuex？
vuex就是多个模块之间的一个共享域，在多个模块进行数据传输的时候，如果数据不方便传输，
那我们就可以放到vuex中

简单使用：
1：安装npm install vuex --save
2：注册vuex插件
3:vue对象中挂载




state：Vuex的基本数据，用来存储变量。
getters：相当于vue的计算属性，state的数据我想返回，但是返回的数据在state基础上要改变，就可以用这个
mutation：提交更新数据的方法，必须是同步的，如果需要异步使用action。每个 mutation 都有一个字符串的事件类型和一个回调函数handler。
action：和mutation的功能大致相同，不同之处在于action 提交的是mutation，而不是直接变更状态。action 可以包含任意异步操作。在浏览器
中可以通过一个devtools浏览器插件进行调试追踪
modules：模块化Vuex，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。



二：mutation的动态响应
1:vuex的store中的数据是响应式的，数据发生改变，页面也随着改变
2:如果在mutation中修改数据，必须使用有响应式的方法，否则修改了，页面不会发生改变





------------------
新项目
1：创建目录结构
2：起别名
3：导入tabbat








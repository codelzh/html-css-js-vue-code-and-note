

# vue基础

# vue重点

1:语法都是写在html标签上面

2:在html标签上	语法=	加上""是字符串	不加""	是data数据或者方法





## vue的几种安装

1：下载.js文件	直接src引入

2：cdn 引入

3：npm安装

现在刚开始学先用第一种简单的





## 创建一个vue

```js
    const app = new Vue({
      el:"#box",  //vue用来管理的dom元素	使用id选择器
      data:{      //数据
        name:"zs",
      },
      methods: {  //用来定义方法的
        get:function(){
          console.log("1");
        }
      },
    })
```





## 插值操作

### Mustach语法插值

Mustach语法就是{{}}	里面写data对象里 的k，vue就会自动解析数据并渲染到dom上	相当于innetText

```html
  <div id="box">
     <!-- {{}}	里面写data对象里的k -->
    <h2>{{name}}</h2>
      
    <!--也可以进行拼接	-->
    <h2>{{name + age}}</h2>
      
  	<!--数字类型可以加减乘除运算	-->
    <h2>{{age * 2}}</h2>

</div>
  
  <script>
    const app = new Vue({
      el:"#box",
      data:{
        name:"zs",
        age:15
      }
    });
  </script>

```





### v-once指令的使用

指令是写在 html标签上的	vue会帮我们解析

v-once	只渲染一次数据，改变数据不会再次渲染

```html
    <h2 v-once>{{name}}</h2>
```





### v-html指令的使用

语法 v-html="data"

v-html：把data数据当作html解析并渲染，相当于innetHtml

```html
  <div id="box">
    <h2 v-html="message"></h2>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        message: "<a href='http://wwww.baidu.com'>baidu</a>",
      }
    });
```





### v-pre指令的使用

v-pre：不解析mustach 语法





## v-bind动态绑定属性

### v-bind的基本使用

v-bind：在dom属性前面添加，那么属性的值就可以是data数据

简写	:

```html
  <div id="box">
      <!-- v-bind添加到属性前面，那么属性的值就可以是data数据 -->
      <img v-bind:src="imgurl" alt="">
      
      <!--	简写 在属性前面写上 : -->
      <img :src="imgurl" alt="">
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        imgurl:"https://www.runoob.com/wp-content/uploads/2017/01/vue.png",
      }
    });
  </script>
```



 

后面可以加boolean来决定是否添加该属性

```html
<button :disabled="true" @click="decrement">111</button>
```





### v-bind在class类的使用

"<div v-bind:class="{类名:boolean}"></div> "

```html
  <div id="box">
    <!-- 在class进行动态绑定时候,我们可以传一个对象   如果boolean为true，那么类名添加，如果false，类名删除
          在开发中，专门在data里面声明一个boolean变量，进行控制
    -->
      
    <!-- <div v-bind:class="{类名:boolean}">{{name}}</div> -->
    <div v-bind:class="{active: isActive}">{{name}}</div>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        name:"zsf",
        //用来控制类名的变量
        isActive:true
      }
    });
  </script>
```



### v-bind在style中的使用

"<div v-bind:style="{css属性名:css属性值}"></div>"

```html
  <div id="box">
    <!-- 在style进行动态绑定时候,我们可以传一个对象   
          在开发中，我们一般自定义一个属性值
    -->
    <!-- <div v-bind:style="{css属性名:css属性值}">{{name}}</div> -->
    <div :style="{color: final}">{{name}}</div>
  </div>

  <script>
    const app = new Vue({
      el: "#box",
      data: {
        name: "zsf",
         //自定义一个属性值
        final:"pink",
      }
    });
  </script>
```



### v-bind实现点击谁，给谁类

```vue
<template>
  <div>
      <!--	2：动态绑定类，在添加事件	-->
    <div v-for="(item,index) in title" :class="{active:index==activeindex}" @click="itemclick(index)">
    </div>
  </div>
</template>

<script>
export default {
  name: "",
  data() {
    return {
        //1：声明一个idnex
      activeindex:0,
    };
  },
  methods:{
    itemclick(index){
      this.activeindex = index;
    }
  },
};
```





## 计算属性

### 使用

计算属性是写在vue{}	里面的	用来处理数据

```js
    const app = new Vue({
      el: "#box",
      data: {
        name: "zsf",
        firstName:"sss",
        lastName:"zzz",
      },
      computed:{
        fullname:function(){
          return this.firstName + this.lastName;
        }
      },
    });
```



### 计算属性和方法的对比

我们发现计算属性和方法很相似

计算属性是有缓存的，如果计算属性里面的值不变，多次调用计算属性，它只会执行一次

方法调用一次，就会执行一次，效率没有计算属性好



## es6的补充

### let和const关键字

let就是var的升级，let声明的变量有作用域，不会出现变量共享问题.

const就是用来定义常量的。

es5没有作用域



### es6对象字面量增强写法

属性

```js
var name = "zs"
var age = 15;

//es5写法，把上面的值，赋值给下面的属性，
var o = {
    name:name;
    age:age
}

//es6写法，结果是相同的
var o = {
    name,
    age,
}
```



方法

```js
//es5写法
var o = {
    run:function(){
        
    }
}

//es6写法	省略了function，结果是一样的
var o = {
    run(){
        
    }
}
```





## v-on事件监听

### 基本使用

语法 v-on:事件=

在vue中，想绑定事件，直接在标签上写v-on



v-on简写(语法糖)

@事件=



```html
  <div id="app">
    <button v-on:click=getName>点击</button>
    <!-- v-on简写1 -->
    <button @click=getName>点击</button>
  </div>
```



@事件=	写方法，直接写

写表达式要带""



### 参数传递event对象

如果想传递event事件对象，那么在实参写上$event

```html
  <div id="app">
      <!--	传递event事件对象	-->
    <button v-on:click=getAge(18,$event)>点击</button>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
      },
      methods: {
        getAge(age,event){
          console.log(age);
          console.log(event);
        }
      },
    });
  </script>
```



### v-on修饰符

修饰符就是在后面加上.

.stop	阻止事件冒泡	

.prevent	阻止元素默认事件

.keyCode	当事件是对应的键盘码，执行事件

.once	执行一次事件

如何使用？在事件后面加上	.对应的修饰符	就行

比如	<button @click.stop=f1></button>



## 条件判断

vue中的条件判断是写在dom标签上的，用来判断是否渲染元素



### v-if和v-else if 和v-else

v-if="boolean"	如果为true就显示元素，false隐藏

```html
  <div id="app">
      <!--	用一个变量控制	-->
    <div v-if=isIf>123</div>
    <div v-else>456</div>
  </div>
```



### key的使用

在vue中，如果有两个相同的元素，vue创建第一个，然后第二个不会创建，会把第一个创建好的元素拿来用，改变属性,id，但是不会改变value属性。如果想渲染两个新的元素，那么在dom元素上加上 key，两个dom元素的key不一样，就会渲染两个

语法 key="值"	值随便填



### v-show

v-show和 v-if 一样，都是决定元素显示和隐藏的

语法 v-show:"boolean"	true显示，false隐藏

区别：

v-show 为false的时候，元素是display:none	隐藏的

v-if	为false，元素直接删除	





## v-for的使用

v-for是写在html标签上的，能遍历几次，就渲染几个元素

### 遍历数组

语法：v-for="item,index in 数组"

item是每次遍历的值，index是下标

```html
  <div id="app">
    <ul>
      <li v-for="item,index in names"> {{index}} {{item}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        names:["zs","ls","ww"],
      },
      methods: {

      },
    });
  </script>
```





### 遍历对象

语法：v-for="value,key,index in 对象"

```html
  <div id="app">
    <ul>
      <li v-for="value,key in stu"> {{value}} {{key}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        stu:{
          name:"zs",
          age:18,
          sex:"man"
        }
      },
      methods: {

      },
    });
  </script>
```





### vue中的点击谁给谁加style

设置一个crrent变量，给每个li添加事件，每次点击，crrent = index，crrent就相当于被点击的那个。然后current和index比较，为true就是点击到了。

```html
  <div id="app">
    <ul>
      <li v-for="item,index in stu" :class="{active:currentIndex === index}" @click="changeColor(index)">{{item}}</li>
    </ul>
  </div>

  <script>
    var app = new Vue({
      el: "#app",
      data: {
        stu: ["zs", "ls", "ww", "xh"],
        currentIndex:0,
      },
      methods: {
        changeColor(index){
          this.currentIndex = index;
        }
      },
    });
  </script>
```









## v-model在表单的使用

### 基本使用

v-model是用来双向绑定的，表单的value变data的数据也变，data数据变，表单value变。

语法	v-model="data数据"

```html
  <div id="app">
    <input type="text" v-model="username">
    {{username}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        username:"",
      }
    });
  </script>
```





### v-model原理

就是给表单value动态绑定数据，然后绑定表单改变事件，发生改变把表单value在给data数据

event.target.value 能获取表单value

```html
  <div id="app">
    <input type="text" :value="username" @input="change">
    {{username}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        username:"123",
      },
      methods: {
        change(){
          this.username = event.target.value
        }
      },
    });
  </script>
```





### 在radio中使用

直接使用就行，没难点。

给radio加上v-model=""	只要是同一个data数据	radio就会互斥

name=""	在提交服务器值是key的存在

```html
  <div id="app">
    <input type="radio" value="男" v-model="sex">男
    <input type="radio" value="女" v-model="sex">女
    {{sex}}
  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        sex:"",
      }
    });
  </script>
```



### 在checkbox中使用

1：单个checkbox，data数据是boolean类型，并且value不用加

2：多个checkbox，data数据是数组类型

```html
  <div id="app">
    <!-- 单个 checkbox 使用  -->
    <input type="checkbox" v-model="isAgree">我同意协议
    {{isAgree}}

    <p></p>
    
    <!-- 多个checkbox的使用 -->
    <input type="checkbox" value="抽烟" v-model="hobby">抽烟
    <input type="checkbox" value="喝酒" v-model="hobby">喝酒
    <input type="checkbox" value="烫头" v-model="hobby">烫头
    {{hobby}}

  </div>

  <script>
    var app = new Vue({
      el:"#app",
      data:{
        isAgree:false,
        hobby:[],
      },
      methods: {
      },
    });
  </script>
```





### v-model修饰符

.lazy	用户在text文本框，敲回车或者光标离开text文本框，data数据才会更新。默认情况是实时更新data

.number	把用户在text文本框的内容变成number类型。默认是string类型

.trim	去掉用户在文本框输入的左右空格。









# 组件化开发

组件化开发就是把一个页面，用多个vue文件来写

## 基本使用

分三步

1：创建组件对象	2：注册组件	3：使用

```html
  <div id="app">
    <!-- 3：使用 -->
    <mycpn></mycpn>
  </div>

  <script>
    //1；创建组件对象
    const cpn = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    //2：注册组件
    // component("组件标签名",组件对象)
    Vue.component("mycpn", cpn);
      
   	  var app = new Vue({
      el: "#app",
    });
  </script>
```







### 局部组件

使用 Vue.component()	注册的组件都是全局组件，能在多个vue实例下使用。但是开发中只会创建一个vue实例，并且使用局部组件

局部组件在vue实例下注册就行了

```js
    //1；创建组件对象
    const cpn = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    var app = new Vue({
      el: "#app",
        //2：注册组件
        //在vue实例里注册组件,k就是标签名,value就是组件对象
      components:{
        mycpn:cpn,
      }
    });
```





### 父子组件

有两个组件cpn1 cpn2，在cpn2里面注册cp1组件，那么cpn2就是父组件，cpn1就是子组件

```js
  <script>
    const cpn1 = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `
    })

    const cpn2 = Vue.extend({
      template: `
        <div>哈哈哈
          <h2>你好啊</h2>
        </div>
      `,
        //在组件2里注册组件1
      components:{
        cpn1:cpn1
      }
    })
```





### 注册组件简写(语法糖)

直接在component(标签名,组件对象)	组建对象传一个对象:	{template:`` }	

```js
  <script>
    //全局组件 语法糖写法
    Vue.component("cpn1",{template:`<div>你好</div>`})


    var app = new Vue({
      el: "#app",
      //局部语法糖写法
      components:{
        cpn2:{template:`<div>哈哈哈哈</div>`}
      }
    });
  </script>
```





### 组件化模版抽离写法

就是把html	写在body里面，不在写到js里面

使用 <template id="cpn1"></template> 标签。然后加上id，{template:id名}	就可以了

```html
<template id="cpn1">
	<div>哈哈哈</div>
</template>

<template id="cpn2">
	<div>呵呵和</div>
</template>


<script>
	//模版抽离
    Vue.component("cpn1",{template:cpn1})


    var app = new Vue({
      el: "#app",
	//模版抽离
      components:{
        cpn2:{template:cpn2}
      }
    });
  </script>
```





### 模块的data

模块也有data，但是data必须是函数类型并且返回对象，这个对象里面就是data数据。这是因为多个模块调用函数，作用域不会共享，对象会共享。

```html
  <template id="cpn1">
    <div>
      {{name}}
    </div>
  </template>

  <script>
    Vue.component("cpn1", {
      template: "#cpn1",
        //data必须是函数类型并且返回对象，这个返回的对象里面就是data数据。
      data() {
        return {
          name: "zs"
        }
      }
    });

    var app = new Vue({
      el:"#app"
    });
  </script>
```







## 组件通信

组件通信就是组件之间的data数据如何进行发送接收



### 父传子类型限制

props:{

name:String,

age:Number,

}

```html
  <div id="app">
    <!--2：在父组件里传数据 -->
    <cpn1 :cname="name" :age="age"></cpn1>
  </div>

  <template id="cpn1">
    <div>
      {{cname}}
      {{age}}
    </div>
  </template>

  <script>
    var cpn1 = {
      template: "#cpn1",
      //1：使用props来接收数据，k就是要接收数据名字，value就是类型限制
      props: {
        cname: String,
        age: Number
      }
    }

    var app = new Vue({
      el: "#app",
      data: {
        name: "zzzzz",
        age: 18
      },
      components: {
        cpn1: cpn1
      }
    });
  </script>
```





### 父传子默认值

要接收的数据的名称是对象

props:{

​	name:{

​	type:String,

​	default:"aaaa"

​	}

}

```html
  <div id="app">
    <!--2：在父组件里传数据 -->
    <cpn1 :cname="name" :age="age"></cpn1>
  </div>

  <template id="cpn1">
    <div>
      {{cname}}
    </div>
  </template>

  <script>
    var cpn1 = {
      template: "#cpn1",
      //1：使用props来接收数据，要接收的数据可以有默认值
      props: {
        cname: {
          type: String, //限制要接收的值的类型
          default: "adssda",  //默认值
          required:true,  //在使用这个模块，必须传这个参数，不然报错
        }
      }
    }

    var app = new Vue({
      el: "#app",
      data: {
        name: "zzzzz",
        age: 18
      },
      components: {
        cpn1: cpn1
      }
    });
  </script>
```





### 子传父

子传父使用自定义事件。

1：先给子元素绑定事件

2：子事件被触发，使用	this.$emit("自定义事件","数据")  来发送给父组件

3：在父组件里的子组件标签上监听这个自定义事件，并且在父组件中写触发的方法

父方法在接收数据时候，只需要形参就行，实参会自动传递

```html
  <div id="app">
    <!--3：在父组件里的子组件标签上监听这个自定义事件，并且在父组件中写触发的方法 -->
    <cpn1 @itemclick="cbtnclick"></cpn1>
  </div>

  <template id="cpn1">
    <div>
      <!-- 1：1：先给子元素绑定事件 -->
      <button v-for="item in books" @click="itemclick(item)">{{item.name}}</button>
    </div>
  </template>

  <script>
    var cpn1 = {
      template: "#cpn1",
      data() {
        return {
          books: [{
              id: "aaa",
              name: "哈利波特"
            },
            {
              id: "bbb",
              name: "三体"
            },
            {
              id: "ccc",
              name: "童年"
            },
            {
              id: "ddd",
              name: "在人间"
            },

          ]
        }
      },
      methods: {
        itemclick(item) {
          //2:子事件被触发，使用	this.emit("自定义事件","数据")  来发送给父组件
          this.$emit("itemclick", item);
        }
      },
    }

    var app = new Vue({
      el: "#app",
      data: {

      },
      components: {
        cpn1: cpn1
      },
      methods: {
        cbtnclick(item) {
          console.log(item);
        }
      },
    });
```





### 组件通信中的双向绑定

父给子传数据，子想要双向绑定，但是子不能绑定props里面的数据，应该在子声明一个data，绑定data。这样避免数据两头更改。

然后在子传父，改变父的数据。





## 组件访问

### 父访问子

在开发中可能需要获取子的属性，方法等信息。

在父中定义一个事件，使用

this.$children	获取所有的子组件，返回类型是数组，里面放着所有子组件，可以通过下标获取指定的子组件，但是开发中一般不用

this.$refs	获取指定的子组件。使用：1：ref要在标签上声明	         2：然后获取指定的	this.$refs.声明的标签名

```html
  <div id="app">
    <cpn></cpn>
      <!--	1：ref要在标签上声明   -->
    <cpn ref="aaa"></cpn>

     <!--	children获取所有子组件   -->
    <button @click="btnclick1">children获取所有子组件</button>

     <!--	refs获取指定组件   -->
    <button @click="btnclick2">refs获取指定组件</button>

  </div>

  <template id="cpn">
    <div>
      哈哈哈
    </div>
  </template>

  <script>
    var app = new Vue({
      el: "#app",
      methods: {
        btnclick1() {
          console.log(this.$children);
        },
        btnclick2(){
          //2：然后获取指定的
          console.log(this.$refs.aaa);
        }
      },
      components: {
        cpn: {
          template: "#cpn",
        }
      }
    });
  </script>
```





## 插槽

### 基本使用

1.定义插槽	2.使用插槽

插槽可以有默认值	<slot>button<slot>

```html
  <div id="app">
    <cpn1>
      <!-- 使用插槽，这个button会替代slot -->
      <button>按钮</button>
    </cpn1>
  </div>

  <template id="cpn1">
    <div>哈哈哈
      <!-- 定义插槽 -->
      <slot></slot>
    </div>
  </template>

  <script>
    var app = new Vue({
      el: "#app",
      components: {
        cpn1: {
          template: cpn1
        }
      }
    });
  </script>
```





### 具名插槽(多个插槽)的使用

```html
  <div id="app">
    <cpn1>
      <!-- 2:然后指定name 代替其中的一个-->
      <button slot="center">按钮</button>
    </cpn1>
  </div>

  <template id="cpn1">
    <div>
      <!-- 1：如果存在多个插槽，那么要给name -->
      <slot name="left">
        <span>我是左</span>
      </slot>

      <slot name="center">
        <span>我是中间</span>
      </slot>

      <slot name="right">
        <span>我是右</span>
      </slot>
    </div>
  </template>

  <script>
    var app = new Vue({
      el: "#app",
      components: {
        cpn1: {
          template: cpn1
        }
      }
    });
  </script>
```





## es6的模块化

### es6的导入导出

开发中引入js文件，一般加上module属性，这样就可以使用 import 和 export

```html
<script type="module" src="aaa.js"></script>
```



导出操作

```js
var flag = true;
export var name = "zs";

function num(){
  console.log("num");
}

export {flag,num}
```



导入操作

```js
import { flag,name } from "./aaa.js";
```



全部导入

```js
import * as data from "./aaa.js"

//使用就是.
data.falg;
data.name
```









# webpack开发

## webpack简介

webpack是前端代码打包工具，把开发代码变成运行版代码。

webpack依赖node node依赖很多包，npm是用来管理node下的包的，node包含npm，安装好node，npm也就有了

![](E:\前端学习\vue再次学习\画图\webpack和node和npm的关系.png)





## 安装

安装好node后，安装webpack	@后面是版本号	-g是全局安装

```bash
npm install webpack@3.6.0 -g
```



## 基本使用

![](E:\前端学习\vue再次学习\画图\目录结构.png)1



把入口文件打包成一个js文件，然后html引用就行。webpack会自动处理js之间的依赖，所以main.js引用多少js文件都可以

```bash
webpack src/main.js dist/bundle.js
```





## webpack的配置

## 这些配置知道什么意思就行，不用背，能复制粘贴使用就行，后面有脚手架.



webpack.config.js 文件用来管理webpack配置的，这个文件是手动创建的

package.json	npm包管理的文件，这个文件使用 npm init 命令创建

 



使用	webpack 代替	webpack src/main.js dist/bundle.js	命令

以下代码知道什么意思就行，是关于配置的

在webpack.config.js 写上

```js
//引入node包
const path = require('path')

module.exports = {
  //入口
  entry:'./src/main.js',
  //出口
    output:{
    path:path.resolve(__dirname ,'dist'),
    filename:'bundle.js'
  }
}
```





局部安装webpack，每个项目都要有自己的webpack

```bash
    npm install webpack@3.6.0 save-dev
```





node命令和webpack的对应

package.json	文件中的script就是node命令和webpack的对应关系

```json
  "scripts": {
      //这个test就等于 npm run test = "echo \"Error: no test specified\" && exit 1"，可以简化代码
    "test": "echo \"Error: no test specified\" && exit 1",
      //就等于 npm run build = "webpack"
    "build":"webpack"
  },

```



script里面的命令，会使用本地的webpack配置







## loader的使用

webpack负责把js打包成一个文件，但是还有css，图片等，webpack是干不了的。这时候就需要loader，loader是用来处理各种文件的，加上loader后，webpack就能打包css，图片等资源

loader的使用：

1：找到你想用的loader	https://webpack.docschina.org/loaders/，安装它

2：配置它

3：style引入main.js文件使用，打包





### 图片的处理

1：安装处理图片的loader	https://webpack.docschina.org/loaders/url-loader/

2：配置

3：打包

注意的点

webpack.config.js文件中的图片loader的配置，limit: 8192

如果图片小于8kb，就使用url-loader，打包的图片就以base64的形式显示。

### 大于8kb的处理

图片大于8kb，就用file-loader，打包的图片是真实图片，会把src的图片复制到dist，这时我们需要配置默认路径才可以找到图片

在webpack.config.js文件中添加publicPath

```js
  output: {
      //这句代码的意思是，所有url链接，都以dist/	开头
    publicPath:"dist/",
  },
```



### 大于8kb图片路径的处理

大于8kb的图片会被复制到dist文件夹，并且图片名字是hash码，很乱。

在webpack.config.js文件中给url-loader添加属性

```json
     options: {
          name:"img/[name].[hash:8].[ext]"
     },
```







### es6转es5

1：下载loader

2：配置

3：打包，会发现bundle.js 变成es5语法

要注意的是，里面开始不是"es2015"，要手动改

```js
presets: ['es2015']
```





## 在webpack中使用vue

1：先使用npm安装vue

2：导入	import Vue from "vue";

3：写vue代码就行

需要注意的是，会报错

![](E:\前端学习\vue再次学习\画图\报错.png)



这句话的意思是，使用的是vue-only版本，这个版本不能编译template模版，所以报错

vue分两个版本

1：runtime-compiler	开发版本，可以编译template模版

2：runtime-only	运行版本，不能编译template模版，只包含了能运行vue代码的东西



我们默认使用的是only版本，所以不能编译template模版(app也是模版)

在webpack.congfig.js中添加一个对象可以解决

```js
module.exports = {
  //入口
  entry: './src/main.js',
  //出口
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
    publicPath: "dist/",
  },

    //意思是，以后运行vue代码时候，往这个目录找，vue.esm.js可以编译模版
  resolve:{
    alias:{
      "vue$":"vue/dist/vue.esm.js"
    }
  }

}
```





## el和template的区别

如果一个实例存在el对象，也存在template对象，那么templa的内容会把el的元素覆盖





## vue最终的方案(开发中到底怎么写)

在开发中，index文件是不需要写代码的。

```js
// ...main.js
//1：导入app.vue
import App from "./vue/App.vue";
new Vue({
    //2：把app对象，替换dom元素
  el:"#app",
  template:"<App/>",
  components:{
    App
  }
})
```

```vue
<!-- app.vue -->
<template>
  <div>
    <h2>哈哈哈哈哈</h2>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      name:"zs",
    };
  },
};
</script>
<style scoped>
  h2{
    color:red;
  }
</style>


```







## 插件的使用

1：npm安装你想要的插件	https://webpack.docschina.org/plugins

2：在webpack.congfig.js	导入插件，并且添加plugins属性。(具体看上面链接)





### html打包dist文件夹的插件

https://webpack.docschina.org/plugins/html-webpack-plugin/

在打包时候，index.html也是要打包dist文件夹下的，webpack默认不会打包，这时候就要用插件了。

```js
//里面跟一个对象，就会以src目录下index.html作为模版，复制到dist文件夹 
plugins: [new HtmlWebpackPlugin({
    template:"index.html"
  })

```



这时候需要把webpack.config.js	的publicPath属性去掉，以后调试就在dist文件夹的index.html，所以不需要路径了。





### 压缩js代码插件

就是把js变成一行，去空格。

https://www.webpackjs.com/plugins/uglifyjs-webpack-plugin/







## 搭建本地服务器

https://www.webpackjs.com/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-server

```bash
npm install --save-dev webpack-dev-server@2.9.3
```



配置具体看上面链接

```js
//在webpack.congfig.js 中配置 
devServer: {
    //要作为本地服务器的目录
    contentBase: './dist',
    //端口号
    port:8081,
    //是否实时刷新
    inline:true,
  },
```



```js
 //在package.json配置脚本，这样命令就能使用本地的webpack
"scripts": {
    "dev": "webpack-dev-server --open"
  },
```







# vuecli使用(脚手架)

1：安装	npm install -g @vue/cli

2：如果想使用vue2的模版，要以下命令	npm install -g @vue/cli-init

https://cli.vuejs.org/zh/guide/installation.html

具体看上方文档





## vuecli2

```bash
//使用下面命令来创建一个cli2的项目
vue init webpack 项目名称
```







## vuecli3

```bash
//使用下面命令来创建一个cli2的项目
vue create 项目名称
```





## runtime-compiler和only的区别

区别就在main.js，一个使用template，一个使用render函数

compiler:在渲染dom元素时候，过程如下:
template -> ast -> render -> vdom - dom
compiler是先把template编译

only:在渲染dom元素的时候，过程如下
render -> vdom -> dom
直接省略了前两步



only效率更高，在开发中一般使用only



render函数就相当于

```js
new Vue({
  el:"#app",
  render:function(createlement){
      //这个参数是render函数给的，用来添加元素，并且覆盖app
      //也可以传一个模板
      //作用和template是一样的，但是效率更高
    return createlement(App);
  }
})
```







# vuerouter(vue路由)

vue路由的核心就是改变url，但是页面不会再去请求资源

存在两种方式

1：location.href = ""	改变url

2：history	对象来改变url







## vuerouter的安装和配置

1：通过npm安装，或者脚手架构建时候，选择vue-router

### 使用

1：导入路由对象，并且调用 vue.use(vuerouter)	因为vuerouter是vue的插件，vue的插件都需要vue.use()

2：创建路由实例，并且传入路由映射配置	

```js
  {
    path:"",
    component:
  }
```

3：导出，在vue实例中挂载路由对象

4：使用，通过<router-link>	和	<router-view>





## 默认路径

```js
  {
    //当路径为空时，重定向在hone页面
    path:"",
    //重定向
    redirect:"/home"
  },
```





## 改变为history模式

```js
const router = new VueRouter({
  routes,
  //在路由对象加上mode属性
  mode:"history",
})
```







## router-link的属性

tag:指定router-link被渲染成什么元素

replace：不会留下history记录

active-class：当router-link被点击，vue会自动给一个class，active-class属性能改变这个给的class





## 通过代码修改url

就是给一个元素绑定事件，然后跳转

使用	tihs.$router

```js
    home() {
      //vue-router会给每一个组件$router属性
      this.$router.push("/home");
    },
```





## 动态路由的使用

动态路由就是，我不确定url后面的参数信息，参数信息不是我决定的

比如 user页面后面在跟上id	user/用户id	这个用户id不能写死

```js
  {
    //这样写就是动态路由
    path:"/user/:id",
    component:user
  }
```





```vue
<div>    
    <!--	然后在跳转页面，拼接上用户id	-->
	<router-link v-bind:to="'/user/' + userid">用户</router-link>
   	<router-view></router-view>
 </div>
</template>

<script>
export default {
  name: "App",
  data(){
    return{
      userid:"zs",
    }
  },
   methods:{
     //代码方式带参数路由跳转
       profilebtn() {
      	this.$router.push({
        path:"profile",
        query:{name:"zs",age:20}
      });
    },
   }
};
</script>
```



### 参数的获取

使用动态路由	    path:/user/:id	这个id就是参数

使用	this.$route	这个对象是被选中的路由组件(当前活跃的组件)，里面包含了参数

```

```



## 路由懒加载

在之前所有js都会打包成一个app.js文件，这个文件会非常大。所以要使用懒加载

在route里index.js	导包时候	这样写

```js
const user = ()=> import("../components/user.vue")
```



这样，每个组件都会打包成一个个的js文件





## 路由嵌套

写children就行，然后在home里写上<router-link>	和 <router-view>

```js
  {
    path: "/home",
    component: home,
    children: [
      {
        path:"",
        component:homeNews
      },
      {
        path: "message",
        component: homeMessage
      },
      {
        path: "news",
        component: homeNews
      }
    ]
  },
```





## 参数传递

一个页面跳到另一个页面，想传一些数据

1：动态路由的方式

2：to里面传一个对象



```vue
<router-link :to="{path:'/profile', query:{name:'zs',age:18}}">档案</router-link>
```



```js
//通过代码的方式传   
profilebtn() {
      this.$router.push({
        path:"profile",
        query:{name:"zs",age:20}
      });
    },
```



## keep-alive的使用

`keep-alive` 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。





# tarbar案例的经验

1：如果想使用插槽，封装组件。那么就先在app里面写好，然后在复制粘贴到组件，一步步来

2：slot 必须使用div 包起来，然后div可以添加属性，要不然在slot上面添加属性，容易被覆盖



动态添加类的思路实现

```js
  computed:{
    isActive(){
      //利用$route 和path 实现排他思想的tabbar 的active类
      //$route是当前活跃的组件
      return this.$route.path.indexOf(this.path) !==-1
    }
  }
```



## 给路径起别名

```js
//在项目根目录创建vue.config.js 注意:文件名称必须是vue.config.js否则不会被解析
//复制如下代码
//记得重启服务
const path = require('path')

function resolve(dir) {
    return path.join(__dirname, dir)
}
module.exports = {
    lintOnSave: true,
    chainWebpack: (config) => {
        config.resolve.alias
            .set('@$', resolve('src'))
            .set('base', resolve('src/base'))
            .set('views',resolve('src/views'))
            .set('common', resolve('src/common'))
            .set('components', resolve('src/components'))
    }
}
```



引入图片不管用，前面加~

# promise的使用

promise就是用来封装异步操作的。

```js
    new Promise(function (resolve, reject) {
      setTimeout(() => {
        //当网络请求成功时候，调用resolve，就会到then处理代码
        // resolve("请求成功的数据");

        //网络请求失败，调用reject，就会到catch处理代码
        reject("请求失败的数据");
      }, 1000);
    }).then(function (data) {
      console.log(data);
    }).catch(function (erro) {
      console.log(erro);
    })
```



## promise的all方法

all方法作用是：如果有多个网络请求，必须同时请求成功，才处理。

```js
    Promise.all([
      new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("data1")
        }, 1000);
      }),

      new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("data2")
        }, 4000);
      }),

    ]).then((data)=>{
      //这个data是数组类型，里面包含上面的结果
      console.log(data);
    })
```



# vuex的使用

vuex是vue的插件，和vuerouter一样。

使用

1：安装	npm install vuex	或者在cli脚手架构建项目时候选择vuex

2：vue.use()	注册

3：创建 vuex.store()	对象

4：导入vuex，挂载到main.js

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  //状态,要共享的数据
  state: {
    name: "zs"
  },
  mutations: {},
  actions: {},
  modules: {}
})
```





在其他组件中通过$store.state.数据	来获取，在vue注册插件vuex时候，会给所有组件添加属性$store	这个$store包含了vuex的信息。和router组件是一样。$router 和$route

```vue
<template>
  <div>
    <h2>我是App</h2>
	//使用
    {{$store.state.name}}
  </div>
</template>
```





## 修改数据

在vuex中，我们修改数据是要通过Actions或者Mutations的，这样我们修改的数据可以使用devtools浏览器工具进行追踪。

![](E:\前端学习\vue再次学习\画图\vuex的修改数据.png)



### Mutations修改数据

1：在vuex文件 Mutation里定义改变数据的方法

2：在组件中使用	$store.commit("Mutation的方法名")	来改变数据

```js
// vuex文件
export default new Vuex.Store({
  //状态,要共享的数据
  state: {
    count:100
  },
  //里面主要写改变数据的函数
  mutations: {
    increment(){
      this.state.count++
    },
    decrement(){
      this.state.count--
    }
  },
  actions: {},
  modules: {}
})
```



```js
//在组件里面，定义方法，使用 this.$store.commit()	来调用Mutation里的方法
methods:{
    add(){
      this.$store.commit("increment")
    },
    odd(){
      this.$store.commit("decrement")
    }
  }
```





## getters的使用

 getters作用和计算属性一样，都是改变数据

```js
export default new Vuex.Store({
  //状态,要共享的数据
  state: {
    count:100
  },
  mutations: {

  },
  //getters作用和计算属性一样，都是在我这里改变数据
  getters:{
    //state是默认给的，getter可以拿到getter里面所有的计算属性，
    towcount(state,getter){
      return state.count * 2;
    }
  },
  actions: {},
  modules: {}
})
```



```js
//在其他组件中使用
{{$store.getters.towcount}}
```





## Mutation的参数传递

```js
    addCount() {
        var count = 10;
        //第二个参数写要传递的数据	可以是对象
      this.$store.commit("incrementCount", count);
    },
```



```js
  mutations: {
      //data形参接收参数
    incrementCount(state,data){
      this.state.count+=data
    }
  },
```





## vuex的数据响应式

如果想添加和删除数据，要使用Vue.set() 和Vue.delete()    来响应式的增加删除vuex的数据

在vuex中，事先写好的数据，对它进行操作可以进行响应式，但是没有的数据，要使用如下方法

其他方法不能做到响应式

```js
//在mutations里面写对应的方法
Vue.set(state.stu,0,"abc")
Vue.delete(state.stu,0)
```





## vuex的actions的使用

在进行异步操作时候，必须通过actions，要不然devtools工具追踪不到。如果异步操作想修改数据，还是要通过mutations

```js
    asynz(){
      //通过$store.dispatch() 进入actions	后面可以传递参数
      this.$store.dispatch("asynz");
    }
```



```js
  actions: {
    //context就是store
    asynz(context) {
      setTimeout(() => {
        //如果异步操作想修改数据，通过mutations	
        context.commit("changState")
      }, 1000);
    }
  },
```





## vuex抽离

![](E:\前端学习\vue再次学习\画图\vuex目录结构.png).







# axios的使用

axios是用来网络请求的

## 安装

```bash
npm install axios
```



## 基本使用

```js
axios(config)
axios({
  url: "http://httpbin.org/get",
  method:"get",
    params:{
      name:'1',
      age:'16'
    }
}).then((res) => {
  console.log(res);
}).catch(()=>{
    
})
```



## 多个请求都成功才处理

```js
axios.all([
  {
    url:'http://httpbin.org/get',
    params:{
      data:{message:'11111'}
    }
  },

  {
    url:'http://httpbin.org/get',
    params:{
      data:{message:'2222'}
    }
  },
]).then(axios.spread((res1,res2)=>{
  console.log(res1);
  console.log(res2);
}))
```





## 修改全局配置默认值

用axios.defaults.配置	来修改默认值

```js
axios.defaults.baseURL='http://httpbin.org',
```



### 自定义实例默认值

```js
//自定义实例默认值
const axios1 = axios.create({
  baseURL:"http://httpbin.org/get",
})

//使用自定义实例
// axios1(config)
axios1({
  url:"",
}).then((res)=>{
  console.log(res);
})
```





## 模块封装

```js
import axios from "axios"

const a = axios.create({
  baseURL: "http://152.136.185.210:7878/api/m5",
  timeout: 5000,
})

export function request(config, success, fail) {
  return a(config)
}
```





# 项目

## 首页

### 数据的请求和数据保存的结构

保存数据的结构

```js
      goods: {
        pop: { page: 0, list: [] },
        new: { page: 0, list: [] },
        sell: { page: 0, list: [] },
      },
```



数据请求的封装

```js
    getgoods(type) {
      let page = this.goods[type].page + 1;

      getgoods(type, page).then((res) => {
        //把结果存放到data里面
        for (let i of res.data.data.list) {
          this.goods[type].list.push(i);
        }
        //当前商品页码+1
        this.goods[type].page += 1;
      });
    },
```



### goods的页面

goods 页面，在home页面父传子，把商品数据传过来。然后有多少条数据，遍历多少gooditem。然后把每条数据传给gooditem

gooditem遍历具体的商品

```vue
//home页面
<goods :goodsdata="goods[currentcategory].list"></goods>
```



### tabcontorl

tabcontorl负责切换数据。当tabcontorl被点击，发出事件并且带上index。home监听到数据，根据index改变currentcategory，

  goods: {
        pop: { page: 0, list: [] },
        new: { page: 0, list: [] },
        sell: { page: 0, list: [] },
      },

goods[pop].list		goods[new].list		goods[sell].list	

那么goods的数据就会改变，页面就刷新

```vue
//home页面
//核心代码
<goods :goodsdata="goods[currentcategory].list"></goods>
```



### 下拉加载更多

监听beeterscroll的下拉到底事件。监听到，发送事件到home并且带上position，home请求数据。



### tabcontorl吸顶效果

获取tabcontorl的offsetTop	和滚动的y 做对比

offsetTop 获取是不准确的，因为图片加载满，offsetTop没把图片算进来

解决1:settTmeout	设置延迟	2：给图片加上load事件，然后获取offsetTop

值得注意的是，fiexd布局在betterscroll里面，同样会被滚去

我们在复制一个tabcontorl，当重叠时候，v-show来判断是否显示，true或者false由offsetTop和滚动的y	对比而来



### home离开时候的状态保留

1：使用keep-alive	不让路由组件销毁

2：用activated()	和	deactivated()	生命周期函数，  离开时候记录y，进入时候把y给scrollTo()







## mounted()加载好调用js失败

当组件渲染好后，在mounted()生命周期函数调用轮播图js，但是js获取不到元素。

原因：没加延迟，vue渲染没跟上

设置settimeout	延迟完美解决

```js
  mounted() {
    var t = this;
    setTimeout(() => {
      //轮播图函数
      t.test();
    }, 1000);
  },
```



## 用flex布局碰上文字溢出隐藏

flex布局直接崩溃，解决：不要设置flex:	给子元素设置百分比，自动撑



## flex布局碰上fiexd定位

同一个元素上面添加这两个属性，布局又崩溃了。原因：width如果没有设置宽度默认是auto

解决： width: 100%;	添加这个

fiexd定位脱表，如果想占位，用一个盒子包住，盒子设置高度。



## betterscroll的bug解决

给图片添加事件，事件被触发，使用事件总线的方式调用betterscroll



## 用防抖函数来限制refresh

每次图片请求，都调用一次refresh，我们可以使用防抖函数，在最后一次调用refresh，提升效率











# betterScroll的使用

BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 [iscroll (opens new window)](https://github.com/cubiq/iscroll)的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。

只要是滑动效果，大多都使用这个。原生也可以做到，但是这个简单。

官网：https://better-scroll.github.io/docs/zh-CN/



要配合betterScroll插件使用：better-scroll/observe-dom，作用：动态计算 BetterScroll 的可滚动高度或者宽度，你并不需要自己在高度或者宽度发生变化的时候，手动调用 refresh() 方法。插件通过 MutationObserver 帮你完成了

这个插件解决了bug：滑动无效



## 安装

```bash
npm install better-scroll --save
```

## 使用

```js
import BetterScroll from 'better-scroll'
    //probeType 加上此属性。监听滚动的回调函数才会执行
    //值  1 不监听
    //    2 监听手指的滚动，惯性滚动不监听
    //    3  只要是滚动都监听
let bs = new BetterScroll('.wrapper', {
    //配置信息
      probeType: 3,
      pullUpLoad: true,
      click:true	//click必须为true，里面的元素才能被触发事件
})

    //滚动事件，position包含了xy坐标
    bs.on("scroll", function (position) {
      // console.log(position);
    })

    //下拉到底部事件
    bs.on('pullingUp', () => {
      console.log("我是底部");
      
      //.......获取数据，把数据放到data

      //下拉到底部事件只会执行一次，下面这个方法代表事情做完了，然后下拉到底部事件会再次执行
      bs.finishPullUp();
    })
```



bs.scrollTo(x,y,time)	回到指定位置

更多参数看文档。



# 事件总线

事件总线和vuex差不多，但是事件总线是用来不同的组件，收发事件的。

```js
//在vue实例添加原形
Vue.prototype.$bus = new Vue()
```



```js
//	A 组件的方法被触发，提交事件 
methods:{
    goodsimgload(){
      this.$bus.$emit("goodsimgload")
    }
  },
```



```js
// 	B	组件接收到对应的事件	并执行回调函数
methods:{
	accept(){
		this.$bus.$on("goodsimgload",function(){
			console.log("执行")
		})
	}
}
```





# 防抖函数

防抖函数：多次触发事件，只会在最后一次触发事件后等待设定的wait时间结束时执行一次

```js
    debounce(func, wait) {
      let timeout;
      return function () {
        if (timeout) clearTimeout(timeout);

        timeout = setTimeout(() => {
          func();
        }, wait);
      };
    },
```



# vue细节

在模版上是可以获取元素的

this.$refs.名称.$el

可以获取模版的所有元素，然后就可以获取元素的值



在模版上可以添加事件	但是要带上native属性	@click.native=	









为什么要使用模块化？
如果不使用模块化，那么会有变量被修改，逻辑错误，不方便维护等问题
什么是模块化？
核心就是导入和导出，模块化也有多种规范：如CommonJS  ES6等

webpack是什么
webpack就是模块和打包,把开发时候写的模块化代码打包成大部分浏览器可以使用的

webpack运行需要(依赖)node,node环境运行需要各种依赖包，npm就是用来管理包的node packages manager


dist目录用来存放用来发布的代码,src存放源代码




---------------------------
一、webpack的基本配置
webpack.config.js文件
每个目录下应该有一个webpack.config.js的文件，这个文件用于配置webpack的
2:webpack自动化打包，在之前使用的打包是webpack ./(要打包的js入口文件)  ./(打包后的js文件)
如何在终端输入webpack 就让它自动打包？

使用如CommonJS命令在config文件里配置
这个path必须是绝对路径，如果直接写上绝对路径，可以是可以，但是项目一旦发生改变，我又要
重新写path==	如何解决？

modlue.exports = {
  entry:'./src/main.js',
  output:{
    path:,
    filename:'bundle.js'
  }
}

package.json文件
使用node命令,使用node命令之前要初始化
npm init


const path = require('path')

这时候可以使用node了，使用path.resolve(__dirname ,'dist')获取绝对路径，这时候就配置好了
module.exports = {
  entry:'./src/main.js',
  output:{
    path:path.resolve(__dirname ,'dist'),
    filename:'bundle.js'
  }
}


全局webpack和局部webpack
全局webpack是计算机上安装的,但是每个项目里面也可以有一个webpack

在项目中安装局部webpack
npm install webpack@3.6.0 save-dev
安装好后json文件多了个dependencies，这个是开发时依赖
save是运行时依赖

命令的简化
npm run .. 
后面的命令是json文件里的script的对象后面语法
写上	"build":"webpack"
npm run build 
自动打包

总结：
1:一个项目先创建webpack.config.js文件，在里面配置webpack打包语法
2:初始化node环境，因为上面的绝对路径有依赖node语法 npm init
3:安装局部webpack  npm install webpack@3.6.0 save-dev

以上三步是webpack的基本配置





----------------------------
二:webpack的css处理
在使用css中，我也希望是模块化，只引用一个
在上面一，基础上添加一个css文件，在main.js中依赖导入(依赖这个css文件)
得webpack在用这一个main.js文件，把css也给我打包了
require("./css/ordinary.css")

npm run build 
报错
You may need an appropriate loader to handle this file type.


所以需要一个loader,loader可以看作webpack的升级，webpack本身只能打包js，
但是我们也需要其他的，所以loader就出现了，不同的loader有不同的功能

我们去官网上找loader webpackjs.com

随后安装npm npm install --save-dev css-loader
--save 指的是运行和开发
--save-dev 只开发时候使用

在webpack.config.js配置

值得一提的是，webpack 的版本和loader 版本，要兼容，如果代码没错，那么请卸载
loader:npm uninstall 名称，在指定loader版本安装 npm install loader名称@3.6(版本号)


css-loader用来加载css的，不会把css加载到html，如果要加载在添加一个style-loader，具体看文档


总结：webpack只能打包js，如果想处理其他文件，请下载不同的loader
最后加载成功，webpack把css代码直接添加到dom中，而我index.html只是引用了一个main.js，就可以做到
全部导入，这一点很厉害..





----------------------------
三：loader处理图片
在css里添加图片，加载css时候会将图片当作模块进行加载

去官网上找处理图片loader
url-loader
npm install --save-dev url-loader@1.1.2

url-loader 
limit: 20000  这个属性，后面是20000kb，如果图片小于这个，
那么在浏览器以base64的形式显示

如果图片大于这个，那么将使用file-loder解析，把图片放到dist目录
filter的使用
如果图片大于limit，发现浏览器并不能解析图片，因为图片在dist目录
在webconfigjs中添加 publicPath:'dist/',   本项目url默认路径都已这个开始

filter-loader有一个属性name。这个属性可以设置在filter图片中的名字


--------------
四：babel-loader
这个loader用来打包模块,把代码全部转为es5





---------------
五：webpack里面使用vue
在webpack中vue也是一个模块
1:安装vue npm install vue --save
2:导入vue  import Vue from 'vue'
3:vue分runtime-only 和 runtime-compiler

runtime-only运行版本，不能有template vue也是一个template所以报错
runtime-compiler 开发版本
默认是 only版本

4:指定版本(官网上有)
module.exports = {
  // ...
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js' // 用 webpack 1 时需用 'vue/dist/vue.common.js'
    }
  }
}



----------------------------
六：vue在webpack中使用
一个组件同时出现template 和el  template的模版会代理el前端挂载的dom
这样前端就不用写代码了,就一个html页面。

npm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev
安装vue模块，这样可以在webpack使用vue



----------------
七：webpack使用插件
插件是webpack的扩充，而loader是类型转换器
具体在官方文档里看吧。。



----------------
八：webpack搭建本地服务器
我们没写一次代码想测试就'webpack'一次，有没有解决办法？
搭建本地服务器 	npm install --save-dev webpack-dev-server@2.9.3
dev-server是一个模块，它的作用是搭建一个本地服务器，我们的代码全在
内存里跑，并且是实时刷新的，我们代码并不会存在硬盘上，代码写好后,'webpack'一次
就存到硬盘了


---------------
九：把webpackconfigjs抽离
我们发现一个config文件里很多代码，我们给它分离出去，一个开发时候用，一个编译时候用



-------------------
十：使用vue cli 构建项目
之前配置太麻烦了，使用cli可以一键配置，cli也依赖node，下载是使用npm的
具体下载看官网




----------------
十一：runtime-compiler 和runtime-only
在构建项目时候可以选择使用这其中一个，这两个有什么区别？
compiler:在渲染dom元素时候，过程如下:
template -> ast -> render -> vdom - dom
compiler是先把template编译

only:在渲染dom元素的时候，过程如下
render -> vdom -> dom
直接省略了前两步

它们的区别在于main.js中。在noly中，我只需要提供一个render函数就可以渲染dom元素 

.vue文件中的template 直接会被vue-template-compiler 这个编译为runder函数，所以only是没有template的存在
	




-----------------------
十二：前端渲染和后端渲染
第一阶段：后端渲染:发送url，后端处理数据，后端使用jsp,php 把数据渲染到dom元素，
在发送给浏览器，浏览器显示

第二阶段:前后端分离：前端先请求静态资源，然后再以ajax的方式像api服务器发送请求，
后端接收数据并处理数据，后端json返回前端，前端接收，在渲染，每次请求都是一次渲染

第三阶段：
spa阶段，前端请求一资源，前端进行不是必须请求数据的操作，就可以从第一次请求的
资源中，进行分离，直接显示到浏览器

后端渲染就是url和后端的一个映射关系，发送哪个url，后端对应的渲染
前端渲染就是url和前端的一个映射关系，后端负责数据传输无须渲染，前端负责数据的展示

后二阶段都是前端渲染



-----------------------
十三：url的hash 和history
location.hash 给当前页面一个值

history.puchState() 给页面一个值，这个值以栈结构保存
history.replaceState() 替换当前页面，不进行保存
history.go(int) 返回或前进栈里面的网页
history.back() 前进一个网页 back()=go(1)


---------------------
十四：npm 使用router前端路由
前端路由就是url和页面的映射关系
cli构建项目时候选择router，在router目录下index.js 注册router插件，创建router对象，导出
rouoter对象，并在main.js中引入router对象



tag="button" 设置路由组件渲染的元素
replace 路由元素不会有历史记录，不进行pushState，
active-class=""	设置单个路由元素默认class值


------------------
十五：通过代码进行路由跳转
给dom绑定事件，组件里写对应的methods，调用this.$router.push('/about')，router
就相是index.js定义的router，vue会给每个模版一个 push=pushState一样

-----------------
十六：动态路由
在某些场面需要传递用户参数，比如 user/userid
这个id怎么从首页传过去？
1:单个传递
1、在router中配置path /user/:userid  :是特殊符号
2、在router-link 配置to v-bind:to="'/user/'+name"  

2:多个传递
1、:to="{path:'profile',query:{name:'zhangsan',age:12}直接在router-link上配置
2、给dom绑定事件，在方法里配还是$router这个方法，只不过是对象形式
this.$router.push({path:'/profile',query:{name:'zhangsan',age:'18'}})

-----------------
十七:嵌套路由
路由下面还有路由，在inex.js(router)配置children


--------------------
十八：路由懒加载
在index.js(router)文件中，配置模块和path对应关系
模块是需要一个个导入的 import ...
但是这样在打包dist文件时候，会全部为打包一个js文件，在后期这个文件会越来越大
用户请求这个文件也会很慢，体验不好

路由懒加载就是解决这的，路由懒加载可以把导入的模块，打包时候分为一个个的js
const profile = () => import('../components/Profile') 路由懒加载的写法



-------------------------
十九：router 和 route
router和route都可以在模块中通过this. 来获取到，因为vue配置的
router 是index.js中的那个router，用来控制页面跳转的，因为它的方法.
route 是 index.js中的route对象，是个数组[],route对象也是routes映射关系的活跃(被点击)对象


----------------
二十：全局守卫
用来监控页面的，有多个方法，如果网页发生对应的操作，将调用这个全局守卫函数


-----------------------
二十一：router-view 和keep-alive
每个模块都有自己的生命周期

//组件生命周期函数，当函数被创建，调用此函数
created(){},

//当函数被销毁，调用此函数，组件显示---路由跳转其他页面，就是一次创建销毁
destroyed(){},

//当组件是活跃状态，执行此函数，此函数对应的组件必须keep-alive里面，才会生效，才不会被销毁
activated() {},

//当组件是不活跃状态，执行此函数，此函数对应的组件必须keep-alive里面，才会生效，才不会被销毁
deactivated(){},

如果模块渲染在route-view中，那么每次点击，跳转其他路由，就是一次生命周期(创建---离开---销毁)

router-view可以在keep-alive中，如果这样，跳转其他路由，本模块被不销毁(创建--离开---依然存在)












------------------------------------------
vueX
一：什么是vuex？
vuex就是多个模块之间的一个共享域，在多个模块进行数据传输的时候，如果数据不方便传输，
那我们就可以放到vuex中

简单使用：
1：安装npm install vuex --save
2：注册vuex插件
3:vue对象中挂载




state：Vuex的基本数据，用来存储变量。
getters：相当于vue的计算属性，state的数据我想返回，但是返回的数据在state基础上要改变，就可以用这个
mutation：提交更新数据的方法，必须是同步的，如果需要异步使用action。每个 mutation 都有一个字符串的事件类型和一个回调函数handler。
action：和mutation的功能大致相同，不同之处在于action 提交的是mutation，而不是直接变更状态。action 可以包含任意异步操作。在浏览器
中可以通过一个devtools浏览器插件进行调试追踪
modules：模块化Vuex，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。



二：mutation的动态响应
1:vuex的store中的数据是响应式的，数据发生改变，页面也随着改变
2:如果在mutation中修改数据，必须使用有响应式的方法，否则修改了，页面不会发生改变





------------------
新项目
1：创建目录结构
2：起别名
3：导入tabbat







